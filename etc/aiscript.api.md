## API Report File for "@syuilo/aiscript"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
class AddAssign {
    constructor(dest: Expression, // 代入先
    expr: Expression, // 式
    loc: Loc);
    // (undocumented)
    dest: Expression;
    // (undocumented)
    expr: Expression;
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "addAssign";
}

// @public (undocumented)
abstract class AiScriptError extends Error {
    constructor(message: string, info?: any);
    // (undocumented)
    info?: any;
    // (undocumented)
    loc?: Loc;
    // (undocumented)
    name: string;
}

// @public
class AiScriptIndexOutOfRangeError extends AiScriptRuntimeError {
    constructor(message: string, info?: any);
}

// @public
class AiScriptNamespaceError extends AiScriptError {
    constructor(message: string, loc: Loc, info?: any);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    name: string;
}

// @public
class AiScriptRuntimeError extends AiScriptError {
    constructor(message: string, info?: any);
    // (undocumented)
    name: string;
}

// @public
class AiScriptSyntaxError extends AiScriptError {
    constructor(message: string, loc: Loc, info?: any);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    name: string;
}

// @public
class AiScriptTypeError extends AiScriptError {
    constructor(message: string, loc: Loc, info?: any);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    name: string;
}

// @public (undocumented)
class And {
    constructor(left: Expression, right: Expression, loc: Loc);
    // (undocumented)
    left: Expression;
    // (undocumented)
    loc: Loc;
    // (undocumented)
    right: Expression;
    // (undocumented)
    type: "and";
}

// @public (undocumented)
const ARR: (arr: VArr['value']) => VArr;

// @public (undocumented)
class Arr {
    constructor(value: Expression[], // アイテム
    loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "arr";
    // (undocumented)
    value: Expression[];
}

// @public (undocumented)
function assertArray(val: Value | null | undefined): asserts val is VArr;

// @public (undocumented)
function assertBoolean(val: Value | null | undefined): asserts val is VBool;

// @public (undocumented)
function assertFunction(val: Value | null | undefined): asserts val is VFn;

// @public (undocumented)
function assertNumber(val: Value | null | undefined): asserts val is VNum;

// @public (undocumented)
function assertObject(val: Value | null | undefined): asserts val is VObj;

// @public (undocumented)
function assertString(val: Value | null | undefined): asserts val is VStr;

// @public (undocumented)
class Assign {
    constructor(dest: Expression, // 代入先
    expr: Expression, // 式
    loc: Loc);
    // (undocumented)
    dest: Expression;
    // (undocumented)
    expr: Expression;
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "assign";
}

declare namespace Ast {
    export {
        isStatement,
        isExpression,
        Loc,
        Node_2 as Node,
        Namespace,
        Meta,
        Statement,
        Definition,
        Attribute,
        Return,
        Each,
        For,
        Loop,
        Break,
        Continue,
        AddAssign,
        SubAssign,
        Assign,
        Expression,
        Not,
        And,
        Or,
        If,
        Fn,
        Match,
        Block,
        Exists,
        Tmpl,
        Str,
        Num,
        Bool,
        Null,
        Obj,
        Arr,
        Identifier,
        Call,
        Index,
        Prop,
        TypeSource,
        NamedTypeSource,
        FnTypeSource
    }
}
export { Ast }

// @public (undocumented)
type Attr_2 = {
    attr?: {
        name: string;
        value: Value;
    }[];
};

// @public (undocumented)
class Attribute {
    constructor(name: string, // 属性名
    value: Expression, // 値
    loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    name: string;
    // (undocumented)
    type: "attr";
    // (undocumented)
    value: Expression;
}

// @public (undocumented)
class Block {
    constructor(statements: (Statement | Expression)[], // 処理
    loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    statements: (Statement | Expression)[];
    // (undocumented)
    type: "block";
}

// @public (undocumented)
const BOOL: (bool: VBool['value']) => VBool;

// @public (undocumented)
class Bool {
    constructor(value: boolean, // 真理値
    loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "bool";
    // (undocumented)
    value: boolean;
}

// @public (undocumented)
const BREAK: () => Value;

// @public (undocumented)
class Break {
    constructor(loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "break";
}

// @public (undocumented)
class Call {
    constructor(target: Expression, // 対象
    args: Expression[], // 引数
    loc: Loc);
    // (undocumented)
    args: Expression[];
    // (undocumented)
    loc: Loc;
    // (undocumented)
    target: Expression;
    // (undocumented)
    type: "call";
}

// @public (undocumented)
const CONTINUE: () => Value;

// @public (undocumented)
class Continue {
    constructor(loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "continue";
}

// @public (undocumented)
class Definition {
    constructor(name: string, // 変数名
    varType: TypeSource | null, // 変数の型
    expr: Expression, // 式
    mut: boolean, // ミュータブルか否か
    attr: Attribute[], // 付加された属性
    loc: Loc);
    // (undocumented)
    attr: Attribute[];
    // (undocumented)
    expr: Expression;
    // (undocumented)
    loc: Loc;
    // (undocumented)
    mut: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    type: "def";
    // (undocumented)
    varType: TypeSource | null;
}

// @public (undocumented)
class Each {
    constructor(_var: string, // イテレータ変数名
    items: Expression, // 配列
    _for: Statement | Expression, // 本体処理
    loc: Loc);
    // (undocumented)
    _for: Statement | Expression;
    // (undocumented)
    items: Expression;
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "each";
    // (undocumented)
    _var: string;
}

// @public (undocumented)
function eq(a: Value, b: Value): boolean;

// @public (undocumented)
const ERROR: (name: string, info?: Value) => Value;

declare namespace errors {
    export {
        AiScriptError,
        NonAiScriptError,
        AiScriptSyntaxError,
        AiScriptTypeError,
        AiScriptNamespaceError,
        AiScriptRuntimeError,
        AiScriptIndexOutOfRangeError
    }
}
export { errors }

// @public (undocumented)
class Exists {
    constructor(identifier: Identifier, // 変数名
    loc: Loc);
    // (undocumented)
    identifier: Identifier;
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "exists";
}

// @public (undocumented)
function expectAny(val: Value | null | undefined): asserts val is Value;

// @public (undocumented)
type Expression = If | Fn | Match | Block | Exists | Tmpl | Str | Num | Bool | Null | Obj | Arr | Not | And | Or | Identifier | Call | Index | Prop;

// @public (undocumented)
const FALSE: {
    type: "bool";
    value: boolean;
};

// @public (undocumented)
const FN: (args: VUserFn['args'], statements: VUserFn['statements'], scope: VUserFn['scope']) => VUserFn;

// @public (undocumented)
class Fn {
    constructor(args: {
        name: string;
        argType: TypeSource | null;
    }[], retType: TypeSource | null, // 戻り値の型
    children: (Statement | Expression)[], // 本体処理
    loc: Loc);
    // (undocumented)
    args: {
        name: string;
        argType: TypeSource | null;
    }[];
    // (undocumented)
    children: (Statement | Expression)[];
    // (undocumented)
    loc: Loc;
    // (undocumented)
    retType: TypeSource | null;
    // (undocumented)
    type: "fn";
}

// @public (undocumented)
const FN_NATIVE: (fn: VNativeFn['native']) => VNativeFn;

// @public (undocumented)
class FnTypeSource {
    constructor(args: TypeSource[], // 引数の型
    result: TypeSource, // 戻り値の型
    loc: Loc);
    // (undocumented)
    args: TypeSource[];
    // (undocumented)
    loc: Loc;
    // (undocumented)
    result: TypeSource;
    // (undocumented)
    type: "fnTypeSource";
}

// @public (undocumented)
class For {
    constructor(_var: string | null, // イテレータ変数名
    from: Expression | null, // 開始値
    to: Expression | null, // 終値
    times: Expression | null, // 回数
    _for: Statement | Expression, // 本体処理
    loc: Loc);
    // (undocumented)
    _for: Statement | Expression;
    // (undocumented)
    from: Expression | null;
    // (undocumented)
    loc: Loc;
    // (undocumented)
    times: Expression | null;
    // (undocumented)
    to: Expression | null;
    // (undocumented)
    type: "for";
    // (undocumented)
    _var: string | null;
}

// @public (undocumented)
function getLangVersion(input: string): string | null;

// @public (undocumented)
class Identifier {
    constructor(name: string, // 変数名
    loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    name: string;
    // (undocumented)
    type: "identifier";
}

// @public (undocumented)
class If {
    constructor(cond: Expression, // 条件式
    then: Statement | Expression, // then節
    elseif: {
        cond: Expression;
        then: Statement;
    }[], _else: Statement | Expression | null, // else節
    loc: Loc);
    // (undocumented)
    cond: Expression;
    // (undocumented)
    _else: Statement | Expression | null;
    // (undocumented)
    elseif: {
        cond: Expression;
        then: Statement;
    }[];
    // (undocumented)
    loc: Loc;
    // (undocumented)
    then: Statement | Expression;
    // (undocumented)
    type: "if";
}

// @public (undocumented)
class Index {
    constructor(target: Expression, // 対象
    index: Expression, // インデックス
    loc: Loc);
    // (undocumented)
    index: Expression;
    // (undocumented)
    loc: Loc;
    // (undocumented)
    target: Expression;
    // (undocumented)
    type: "index";
}

// @public (undocumented)
export class Interpreter {
    constructor(consts: Record<string, Value>, opts?: {
        in?(q: string): Promise<string>;
        out?(value: Value): void;
        err?(e: AiScriptError): void;
        log?(type: string, params: Record<string, any>): void;
        maxStep?: number;
    });
    // (undocumented)
    abort(): void;
    // (undocumented)
    static collectMetadata(script?: Ast.Node[]): Map<any, any> | undefined;
    // (undocumented)
    exec(script?: Ast.Node[]): Promise<void>;
    execFn(fn: VFn, args: Value[]): Promise<Value>;
    execFnSimple(fn: VFn, args: Value[]): Promise<Value>;
    // (undocumented)
    registerAbortHandler(handler: () => void): void;
    // (undocumented)
    scope: Scope;
    // (undocumented)
    stepCount: number;
    // (undocumented)
    unregisterAbortHandler(handler: () => void): void;
}

// @public (undocumented)
function isArray(val: Value): val is VArr;

// @public (undocumented)
function isBoolean(val: Value): val is VBool;

// @public (undocumented)
function isExpression(x: Node_2): x is Expression;

// @public (undocumented)
function isFunction(val: Value): val is VFn;

// @public (undocumented)
function isNumber(val: Value): val is VNum;

// @public (undocumented)
function isObject(val: Value): val is VObj;

// @public (undocumented)
function isStatement(x: Node_2): x is Statement;

// @public (undocumented)
function isString(val: Value): val is VStr;

// @public (undocumented)
function jsToVal(val: any): Value;

// @public
type Loc = {
    line: number;
    column: number;
};

// @public (undocumented)
class Loop {
    constructor(statements: (Statement | Expression)[], // 処理
    loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    statements: (Statement | Expression)[];
    // (undocumented)
    type: "loop";
}

// @public (undocumented)
class Match {
    constructor(about: Expression, // 対象
    qs: {
        q: Expression;
        a: Statement | Expression;
    }[], _default: Statement | Expression | null, // デフォルト値
    loc: Loc);
    // (undocumented)
    about: Expression;
    // (undocumented)
    _default: Statement | Expression | null;
    // (undocumented)
    loc: Loc;
    // (undocumented)
    qs: {
        q: Expression;
        a: Statement | Expression;
    }[];
    // (undocumented)
    type: "match";
}

// @public (undocumented)
class Meta {
    constructor(name: string | null, // 名
    value: Expression, // 値
    loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    name: string | null;
    // (undocumented)
    type: "meta";
    // (undocumented)
    value: Expression;
}

// @public (undocumented)
class NamedTypeSource {
    constructor(name: string, // 型名
    inner: TypeSource | null, // 内側の型
    loc: Loc);
    // (undocumented)
    inner: TypeSource | null;
    // (undocumented)
    loc: Loc;
    // (undocumented)
    name: string;
    // (undocumented)
    type: "namedTypeSource";
}

// @public (undocumented)
class Namespace {
    constructor(name: string, // 空間名
    members: (Definition | Namespace)[], // メンバー
    loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    members: (Definition | Namespace)[];
    // (undocumented)
    name: string;
    // (undocumented)
    type: "ns";
}

// @public (undocumented)
type Node_2 = Namespace | Meta | Statement | Expression | TypeSource | Attribute;

// @public
class NonAiScriptError extends AiScriptError {
    constructor(error: any);
    // (undocumented)
    name: string;
}

// @public (undocumented)
class Not {
    constructor(expr: Expression, // 式
    loc: Loc);
    // (undocumented)
    expr: Expression;
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "not";
}

// @public (undocumented)
const NULL: {
    type: "null";
};

// @public (undocumented)
class Null {
    constructor(loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "null";
}

// @public (undocumented)
const NUM: (num: VNum['value']) => VNum;

// @public (undocumented)
class Num {
    constructor(value: number, // 数値
    loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "num";
    // (undocumented)
    value: number;
}

// @public (undocumented)
const OBJ: (obj: VObj['value']) => VObj;

// @public (undocumented)
class Obj {
    constructor(value: Map<string, Expression>, // プロパティ
    loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "obj";
    // (undocumented)
    value: Map<string, Expression>;
}

// @public (undocumented)
class Or {
    constructor(left: Expression, right: Expression, loc: Loc);
    // (undocumented)
    left: Expression;
    // (undocumented)
    loc: Loc;
    // (undocumented)
    right: Expression;
    // (undocumented)
    type: "or";
}

// @public (undocumented)
export class Parser {
    constructor();
    // (undocumented)
    addPlugin(type: PluginType, plugin: ParserPlugin): void;
    // (undocumented)
    static parse(input: string): Ast.Node[];
    // (undocumented)
    parse(input: string): Ast.Node[];
}

// @public (undocumented)
export type ParserPlugin = (nodes: Ast.Node[]) => Ast.Node[];

// @public (undocumented)
export type PluginType = 'validate' | 'transform';

// @public (undocumented)
class Prop {
    constructor(target: Expression, // 対象
    name: string, // プロパティ名
    loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    name: string;
    // (undocumented)
    target: Expression;
    // (undocumented)
    type: "prop";
}

// @public (undocumented)
function reprValue(value: Value, literalLike?: boolean, processedObjects?: Set<object>): string;

// @public (undocumented)
const RETURN: (v: VReturn['value']) => Value;

// @public (undocumented)
class Return {
    constructor(expr: Expression, // 式
    loc: Loc);
    // (undocumented)
    expr: Expression;
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "return";
}

// @public (undocumented)
export class Scope {
    constructor(layerdStates?: Scope['layerdStates'], parent?: Scope, name?: Scope['name']);
    add(name: string, variable: Variable): void;
    assign(name: string, val: Value): void;
    // Warning: (ae-forgotten-export) The symbol "Variable" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    createChildScope(states?: Map<string, Variable>, name?: Scope['name']): Scope;
    exists(name: string): boolean;
    get(name: string): Value;
    getAll(): Map<string, Variable>;
    // (undocumented)
    name: string;
    // (undocumented)
    opts: {
        log?(type: string, params: Record<string, any>): void;
        onUpdated?(name: string, value: Value): void;
    };
}

// @public (undocumented)
type Statement = Definition | Return | Each | For | Loop | Break | Continue | Assign | AddAssign | SubAssign | Expression;

// @public (undocumented)
const STR: (str: VStr['value']) => VStr;

// @public (undocumented)
class Str {
    constructor(value: string, // 文字列
    loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "str";
    // (undocumented)
    value: string;
}

// @public (undocumented)
class SubAssign {
    constructor(dest: Expression, // 代入先
    expr: Expression, // 式
    loc: Loc);
    // (undocumented)
    dest: Expression;
    // (undocumented)
    expr: Expression;
    // (undocumented)
    loc: Loc;
    // (undocumented)
    type: "subAssign";
}

// @public (undocumented)
class Tmpl {
    constructor(tmpl: (string | Expression)[], // 処理
    loc: Loc);
    // (undocumented)
    loc: Loc;
    // (undocumented)
    tmpl: (string | Expression)[];
    // (undocumented)
    type: "tmpl";
}

// @public (undocumented)
const TRUE: {
    type: "bool";
    value: boolean;
};

// @public (undocumented)
type TypeSource = NamedTypeSource | FnTypeSource;

// @public (undocumented)
const unWrapRet: (v: Value) => Value;

declare namespace utils {
    export {
        expectAny,
        assertBoolean,
        assertFunction,
        assertString,
        assertNumber,
        assertObject,
        assertArray,
        isBoolean,
        isFunction,
        isString,
        isNumber,
        isObject,
        isArray,
        eq,
        valToString,
        valToJs,
        jsToVal,
        getLangVersion,
        reprValue
    }
}
export { utils }

// @public (undocumented)
function valToJs(val: Value): any;

// @public (undocumented)
function valToString(val: Value, simple?: boolean): string;

// @public (undocumented)
type Value = (VNull | VBool | VNum | VStr | VArr | VObj | VFn | VReturn | VBreak | VContinue | VError) & Attr_2;

declare namespace values {
    export {
        VNull,
        VBool,
        VNum,
        VStr,
        VArr,
        VObj,
        VFn,
        VUserFn,
        VNativeFn,
        VReturn,
        VBreak,
        VContinue,
        VError,
        Attr_2 as Attr,
        Value,
        NULL,
        TRUE,
        FALSE,
        NUM,
        STR,
        BOOL,
        OBJ,
        ARR,
        FN,
        FN_NATIVE,
        RETURN,
        BREAK,
        CONTINUE,
        unWrapRet,
        ERROR
    }
}
export { values }

// @public (undocumented)
type VArr = {
    type: 'arr';
    value: Value[];
};

// @public (undocumented)
type VBool = {
    type: 'bool';
    value: boolean;
};

// @public (undocumented)
type VBreak = {
    type: 'break';
    value: null;
};

// @public (undocumented)
type VContinue = {
    type: 'continue';
    value: null;
};

// @public (undocumented)
type VError = {
    type: 'error';
    value: string;
    info?: Value;
};

// @public (undocumented)
type VFn = VUserFn | VNativeFn;

// @public
type VNativeFn = VFnBase & {
    native: (args: (Value | undefined)[], opts: {
        call: (fn: VFn, args: Value[]) => Promise<Value>;
        topCall: (fn: VFn, args: Value[]) => Promise<Value>;
        registerAbortHandler: (handler: () => void) => void;
        unregisterAbortHandler: (handler: () => void) => void;
    }) => Value | Promise<Value> | void;
};

// @public (undocumented)
type VNull = {
    type: 'null';
};

// @public (undocumented)
type VNum = {
    type: 'num';
    value: number;
};

// @public (undocumented)
type VObj = {
    type: 'obj';
    value: Map<string, Value>;
};

// @public (undocumented)
type VReturn = {
    type: 'return';
    value: Value;
};

// @public (undocumented)
type VStr = {
    type: 'str';
    value: string;
};

// Warning: (ae-forgotten-export) The symbol "VFnBase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type VUserFn = VFnBase & {
    native?: undefined;
    statements: Node_2[];
    scope: Scope;
};

// (No @packageDocumentation comment for this package)

```
